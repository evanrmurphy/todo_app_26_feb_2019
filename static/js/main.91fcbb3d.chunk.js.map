{"version":3,"sources":["logo.svg","TodoApp.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","TodoApp","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","todos","onFormSubmit","bind","assertThisInitialized","onDeleteButtonClick","event","newTodo","target","value","length","setState","prevState","prevProps","concat","toConsumableArray","preventDefault","index","dataset","reduce","acc","todo","i","_this2","react_default","a","createElement","className","onSubmit","type","name","map","key","dangerousString","Array","from","char","charCodeAt","join","data-index","onClick","React","Component","App","src_TodoApp","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"qIAAAA,EAAAC,QAAiBC,EAAAC,EAAuB,6MCiHzBC,cAxEb,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACjBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KAIDQ,MAAQ,CACXC,MAAO,IAGTR,EAAKS,aAAeT,EAAKS,aAAaC,KAAlBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KACpBA,EAAKY,oBAAsBZ,EAAKY,oBAAoBF,KAAzBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KAVVA,4EAaNa,GAEX,IAAMC,EAAUD,EAAME,OAAOD,QAAQE,MAItB,MAAXF,GAAsC,IAAnBA,EAAQG,SAE/Bd,KAAKe,SAAS,SAACC,EAAWC,GACxB,MAAO,CACLZ,MAAK,GAAAa,OAAApB,OAAAqB,EAAA,EAAArB,CAAMkB,EAAUX,OAAhB,CAAuBM,OAIhCD,EAAMU,8DAGYV,GAClB,IAEMW,GAFiBX,EAAME,OACGU,QAAQD,MAGxCrB,KAAKe,SAAS,SAACC,EAAWC,GAOxB,MAAO,CACLZ,MANmBW,EAAUX,MAAMkB,OAAO,SAACC,EAAKC,EAAMC,GACtD,OAAIA,IAAML,EAAcG,EACxB,GAAAN,OAAApB,OAAAqB,EAAA,EAAArB,CAAW0B,GAAX,CAAgBC,KACf,wCAQE,IAAAE,EAAA3B,KACP,OACE4B,EAAAC,EAAAC,cAAA,OAAKC,UAAU,WACbH,EAAAC,EAAAC,cAAA,QAAME,SAAUhC,KAAKM,cACnBsB,EAAAC,EAAAC,cAAA,SAAOG,KAAK,OAAOC,KAAK,YACxBN,EAAAC,EAAAC,cAAA,UAAQG,KAAK,UAAb,OACAL,EAAAC,EAAAC,cAAA,UACG9B,KAAKI,MAAMC,MAAM8B,IAAI,SAACV,EAAMJ,GAC3B,OACEO,EAAAC,EAAAC,cAAA,MAAIM,IAAG,SAAAlB,QAlEGmB,EAkEyBZ,EAjExBa,MAAMC,KAAKF,GAAiBF,IAAI,SAACK,EAAMnB,GAC9D,WAAAH,OAAYmB,EAAgBI,WAAWpB,GAAvC,OAGsBqB,KAAK,OA8DZjB,EACDG,EAAAC,EAAAC,cAAA,UAAQa,aAAYtB,EAAOuB,QAASjB,EAAKlB,qBAAzC,WApElB,IAA0B4B,cAQJQ,IAAMC,WCzBbC,mLARX,OACEnB,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACbH,EAAAC,EAAAC,cAACkB,EAAD,cAJUF,aCOEG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO3B,EAAAC,EAAAC,cAAC0B,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.91fcbb3d.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from 'react';\n\n// Input field\n// Add on enter or button?\n// Todo table or list\n// Each row has delete button\n// Delete removes item\n// jQuery and React on the page, not suffering overhead\n// shimmed/polyfilled etc.\n\n/**\n\n  Write a \"to do\" app. The page should have an input field with some way to submit.  \n  The user enters data (such as 'pet cat') into the field and submits it.  On submission, \n  add a new row to the 'TODO' table/list/whatever  at the bottom.  Each row of the list should \n  have a delete btn, and the content the user entered.  On Delete svisually remove that row \n  from the table / list. Note: you don't have to use a table tag :D\n  ```\n  +------------------+\n  |    TODO     |\n  +------------------+\n  | Pet Cat | delete |\n  +------------------+\n  | Pet Dog | delete |\n  +------------------+\n  | Get Gas | delete |\n  +------------------+\n  | Buy Food| delete |\n  +------------------+\n  ```\n**/\n\nfunction safeEscapeString(dangerousString) {\n  const escapedCharArray = Array.from(dangerousString).map((char, index) => {\n    return `&#${dangerousString.charCodeAt(index)};`;\n  });\n\n  return escapedCharArray.join('');\n}\n\nclass TodoApp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // FIXME: Using todos array with indices for element keys could cause\n    // bugs! It would be better to use unique ids for each todo item.\n    this.state = {\n      todos: [],\n    };\n\n    this.onFormSubmit = this.onFormSubmit.bind(this);\n    this.onDeleteButtonClick = this.onDeleteButtonClick.bind(this);\n  }\n\n  onFormSubmit(event) {\n    // check syntax\n    const newTodo = event.target.newTodo.value;\n\n    // TODO: Remove leading and trailing whitespace, alert user\n\n    if (newTodo == null || newTodo.length === 0) return;\n\n    this.setState((prevState, prevProps) => {\n      return {\n        todos: [...prevState.todos, newTodo],\n      };\n    });\n\n    event.preventDefault();\n  }\n\n  onDeleteButtonClick(event) {\n    const deleteButtonEl = event.target;\n    const indexStr = deleteButtonEl.dataset.index;\n    const index = +indexStr;\n\n    this.setState((prevState, prevProps) => {\n      // double check reduce syntax\n      const updatedTodos = prevState.todos.reduce((acc, todo, i) => {\n        if (i === index) return acc;\n        return [...acc, todo];\n      }, []);\n\n      return {\n        todos: updatedTodos,\n      };\n    });\n  }\n\n  render() {\n    return (\n      <div className='TodoApp'>\n        <form onSubmit={this.onFormSubmit}>\n          <input type='text' name='newTodo' />\n          <button type='submit'>Add</button>\n          <ul>\n            {this.state.todos.map((todo, index) => {\n              return (\n                <li key={`index-${safeEscapeString(todo)}`}>\n                  {todo}\n                  <button data-index={index} onClick={this.onDeleteButtonClick}>\n                    Delete\n                  </button>\n                </li>\n              );\n            })}\n          </ul>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default TodoApp;\n\n//TodoApp.nextId = 0;\n\n// Undo functionality:\n// - For n undos\n// - Keep n snapshots of `todos` historical state\n// - For better space efficiency, keep diff from each state to next instead of full snapshot\n\n// Edge case:\n// Long string input\n// Todo list gets too long?\n// Empty string input\n// XSS? <script>alert('xssed')</script>\n//\n//\n//232\n\n//const todoApp = new TodoApp();\n// bind to DOM\n","import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport TodoApp from './TodoApp.js';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className='App'>\n        <TodoApp />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}